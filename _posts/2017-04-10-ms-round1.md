--- 
layout: post 
title: 微软2017年预科生计划在线编程笔试1
date: 2017-04-10 
categories: blog 
tags: [hihocode] 
description: OJ练习
--- 

# 微软2017年预科生计划在线编程笔试1


## 问题1

### 地址

http://hihocoder.com/contest/mstest2017march/problem/1

### 思路

其实每次获得`legendary item`都是独立的（获取之后，概率会被重置为原来的一半），所以每次计算取得一个`legendary item`需要的平均操作次数即可。

### 代码

```cpp
#include <iostream>
#include <cstdio>  
#include <iostream>  
#include <string>  
#include <iterator>  
#include <algorithm>  
#include <vector>  
#include <cstring>  
#include <array>  
#include <queue>  
#include <set>
#include <cmath>
#include <unordered_set>
#include <map>  
using namespace std;


int P, Q, N;

double solve(double p, double q) {
    p = p / 100.;
    q = q / 100.;
    // cout<<p<<" "<<q<<endl;
    double step = p;
    double res = p;
    double pre = 1.;
    int depth = 1;
    while(true) {
        pre *= (1 - step);
        step += q;
        depth++;
        res += pre * depth * min(step, 1.);
        if(step >= 1.) {
            break;
        }
    }
    return res;
}

 
int main()  
{  
    scanf("%d %d %d", &P, &Q, &N);  
    double res = 0.;
    for(int i=1;i<=N;i++) {
        res += solve((double)P, (double)Q);
        P /= 2;
    }
    printf("%.2f\n", res);
    return 0;  
}  
```


## 问题2

### 地址

http://hihocoder.com/contest/mstest2017march/problem/2

### 思路

自底向上。首先，确认下几个规律：

1. 一层最左边的结点的父节点一定是上层第一个非叶子结点；
2. 相邻结点之间距离为2时，两个结点的父节点相同；
3. 相邻结点之间距离大于2时，两个结点的父节点不同，但是两个结点的父节点一定相邻。

根据上面的规律，我们进行如下步骤：

1. 从左到右遍历一层结点。对于一个结点，首先找到其父节点（根据上面规则）；
2. 将该结点和其父结点关联；
3. 对其父结点进行更新，计算该父结点与其他所有结点的距离。

注意两个问题：

1. 建立的关系表是N\*N的，而不是K*K的；
2. 相邻两个结点的距离必须是已知的或者已经计算出来了（因为要根据这两个结点的距离来判定是否属于同一个父结点）。


### 代码

```cpp
#include <iostream>
#include <cstdio>  
#include <iostream>  
#include <string>  
#include <iterator>  
#include <algorithm>  
#include <vector>  
#include <cstring>  
#include <array>  
#include <queue>  
#include <set>
#include <unordered_set>
#include <map>  
using namespace std;


int dis[110][110] = {0};
int rt[110] = {0};
int N, M, K; 

void solve(vector<vector<int> >& level, unordered_set<int>& leaves) {
    for(int i=level.size()-1;i>=1;i--) {
        int upper = 0;
        while(upper < level[i-1].size() && leaves.count(level[i-1][upper]) > 0)upper++;
        for(int n=1;n<=N;n++) {
            if(dis[level[i][0]][n] > 0)
                dis[level[i-1][upper]][n] = dis[n][level[i-1][upper]] = dis[level[i][0]][n] - 1;
        }
        for(int j=0;j<level[i].size();j++) {
            if(j == 0) {
                rt[level[i][j]] = level[i-1][upper];
                continue;
            }
            if(dis[level[i][j-1]][level[i][j]] != 2) {
                upper++;
                while(upper < level[i-1].size() && leaves.count(level[i-1][upper]) > 0) {
                    upper++;
                }
                for(int n=1;n<=N;n++) {
                    if(dis[level[i][j]][n] > 0)
                    dis[level[i-1][upper]][n] = dis[n][level[i-1][upper]] = dis[level[i][j]][n] - 1;
                }
            }
                rt[level[i][j]] = level[i-1][upper];

        }
    }

}

 
int main()  
{  
    scanf("%d %d %d", &N, &M, &K);  
    vector<int> depth(M, 0);
    for(int i=0;i<M;i++)
        cin>>depth[i];
    vector<vector<int> > level;
    for(int i=0;i<M;i++) {
        vector<int> tmp;
        int val;
        for(int j=0;j<depth[i];j++) {
            cin>>val;
            tmp.push_back(val);
        }
        level.push_back(tmp);
    }
    unordered_set<int> leaves;
    vector<int> l(K, 0);
    for(int i=0;i<K;i++) {
        int tmp;
        cin>>tmp;
        leaves.insert(tmp);
        l[i] = tmp;
    }
    for(int i=0;i<K;i++) {
        for(int j=0;j<K;j++) {
            cin>>dis[l[i]][l[j]];
        }
    }
    solve(level, leaves);
    for(int i=1;i<=N-1;i++) {
        cout<<rt[i]<<" ";
    }
    cout<<rt[N]<<endl;
    return 0;  
}  
```